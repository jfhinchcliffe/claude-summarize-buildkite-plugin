#!/bin/bash
set -euoeuo pipefail

DIR="$(cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd)"

# shellcheck source=lib/plugin.bash
. "$DIR/../lib/plugin.bash"
# shellcheck source=lib/logs.bash
. "$DIR/../lib/logs.bash"

CUSTOM_PROMPT=$(plugin_read_config CUSTOM_PROMPT "")

# Get Buildkite API token from plugin config or environment
BUILDKITE_API_TOKEN=$(plugin_read_config API_TOKEN "${BUILDKITE_API_TOKEN:-}")

API_KEY="${BUILDKITE_AGENT_ACCESS_TOKEN:-}"
if [ -z "${API_KEY}" ]; then
  echo "Error: BUILDKITE_AGENT_ACCESS_TOKEN not available" >&2
  exit 1
fi
# Check if build has any failures
# First check current step
EXIT_STATUS="${BUILDKITE_COMMAND_EXIT_STATUS:-0}"
SOFT_FAILED="${SOFT_FAIL:-0}"
CURRENT_STEP_FAILED=false

if [ "${EXIT_STATUS}" -ne 0 ] || [ "${SOFT_FAILED}" -ne 0 ]; then
  CURRENT_STEP_FAILED=true
fi

# Then check if any other jobs in the build have failed (if API token available)
BUILD_HAS_FAILURES=false
if [ -n "${BUILDKITE_API_TOKEN}" ]; then
  if check_build_has_failures "${BUILDKITE_API_TOKEN}"; then
    BUILD_HAS_FAILURES=true
  fi
fi

# Only analyze if there are failures (current step or other jobs)
if [ "${CURRENT_STEP_FAILED}" = false ] && [ "${BUILD_HAS_FAILURES}" = false ]; then
  # No failures detected - skip analysis
  echo "No failures detected, skipping analysis"
  exit 0
fi
echo "--- Analyzing build failure"

# Get logs
if [ -n "${BUILDKITE_API_TOKEN}" ]; then
  echo "Fetching build logs from Buildkite API..."
  LOG_FILE=$(fetch_build_logs "${BUILDKITE_API_TOKEN}" "1000" "step")
else
  echo "Warning: No BUILDKITE_API_TOKEN provided, using fallback logs" >&2
  LOG_FILE=$(fetch_build_logs "" "1000" "step")
fi

if [ ! -f "${LOG_FILE}" ]; then
  echo "Error: Could not retrieve logs" >&2
  exit 1
fi

LOGS=$(cat "${LOG_FILE}")

# Build prompt
PROMPT="You are analyzing a failed Buildkite job.

Job: ${BUILDKITE_LABEL:-Unknown}
Command: ${BUILDKITE_COMMAND:-Unknown}
Exit Status: ${EXIT_STATUS}
Soft Failed: ${SOFT_FAILED}

Logs:
\`\`\`
${LOGS}
\`\`\`
"

if [ -n "${CUSTOM_PROMPT}" ]; then
  PROMPT="${PROMPT}

${CUSTOM_PROMPT}
"
fi

PROMPT="${PROMPT}

Identify the root cause and provide specific steps to fix it. Be concise."

# Call API
RESPONSE_FILE="/tmp/claude_response_${BUILDKITE_BUILD_ID}.json"
PAYLOAD_FILE="/tmp/claude_payload_${BUILDKITE_BUILD_ID}.json"

echo "${PROMPT}" > "/tmp/claude_prompt_${BUILDKITE_BUILD_ID}.txt"

jq -n \
  --arg model "claude-3-7-sonnet-20250219" \
  --rawfile prompt "/tmp/claude_prompt_${BUILDKITE_BUILD_ID}.txt" \
  '{
    model: $model,
    max_tokens: 2000,
    messages: [{
      role: "user",
      content: $prompt
    }]
  }' > "${PAYLOAD_FILE}"

HTTP_CODE=$(curl -s -w "%{http_code}" \
  --max-time 60 \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer ${API_KEY}" \
  -d "@${PAYLOAD_FILE}" \
  "https://agent.buildkite.com/v3/ai/anthropic/v1/messages" \
  -o "${RESPONSE_FILE}")

if [ "${HTTP_CODE}" -ne 200 ]; then
  echo "Error: API call failed with HTTP ${HTTP_CODE}" >&2
  exit 1
fi

# Extract response
ANALYSIS=$(jq -r '.content[0].text // empty' "${RESPONSE_FILE}" 2>/dev/null)

if [ -z "${ANALYSIS}" ]; then
  echo "Error: Could not parse response" >&2
  exit 1
fi

# Create annotation
ANNOTATION_FILE="/tmp/claude_annotation_${BUILDKITE_BUILD_ID}.md"
cat > "${ANNOTATION_FILE}" << EOF
## Build Failure Analysis

**Pipeline:** ${BUILDKITE_PIPELINE_SLUG} | **Build:** [#${BUILDKITE_BUILD_NUMBER}](${BUILDKITE_BUILD_URL}) | **Step:** ${BUILDKITE_LABEL}

${ANALYSIS}
EOF

buildkite-agent annotate \
  --style "error" \
  --context "claude-analysis-${BUILDKITE_BUILD_ID}" \
  < "${ANNOTATION_FILE}"

exit 0
